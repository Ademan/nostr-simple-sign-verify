/*! For license information please see bundle.js.LICENSE.txt */
(()=>{"use strict";var t={d:(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{OG:()=>ct,My:()=>et,Ph:()=>ot,lX:()=>it,Id:()=>ut,fg:()=>lt,qj:()=>at,aT:()=>nt,lq:()=>st,z:()=>ft,Q5:()=>gt}),"object"==typeof globalThis&&"crypto"in globalThis&&globalThis.crypto;const r=t=>t instanceof Uint8Array,n=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),o=(t,e)=>t<<32-e|t>>>e;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");const i=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function s(t){if(!r(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=i[t[r]];return e}function f(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!r(t))throw new Error("expected Uint8Array, got "+typeof t);return t}class a{clone(){return this._cloneInto()}}function u(t){const e=e=>t().update(f(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function c(t){if(!Number.isSafeInteger(t))throw new Error(`Wrong integer: ${t}`)}function h(...t){const e=(t,e)=>r=>t(e(r)),r=Array.from(t).reverse().reduce(((t,r)=>t?e(t,r.encode):r.encode),void 0),n=t.reduce(((t,r)=>t?e(t,r.decode):r.decode),void 0);return{encode:r,decode:n}}function d(t){return{encode:e=>{if(!Array.isArray(e)||e.length&&"number"!=typeof e[0])throw new Error("alphabet.encode input should be an array of numbers");return e.map((e=>{if(c(e),e<0||e>=t.length)throw new Error(`Digit index outside alphabet: ${e} (alphabet: ${t.length})`);return t[e]}))},decode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("alphabet.decode input should be array of strings");return e.map((e=>{if("string"!=typeof e)throw new Error(`alphabet.decode: not string element=${e}`);const r=t.indexOf(e);if(-1===r)throw new Error(`Unknown letter: "${e}". Allowed: ${t}`);return r}))}}}function l(t=""){if("string"!=typeof t)throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&"string"!=typeof e[0])throw new Error("join.encode input should be array of strings");for(let t of e)if("string"!=typeof t)throw new Error(`join.encode: non-string input=${t}`);return e.join(t)},decode:e=>{if("string"!=typeof e)throw new Error("join.decode input should be string");return e.split(t)}}}function w(t,e="="){if(c(t),"string"!=typeof e)throw new Error("padding chr should be string");return{encode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let t of r)if("string"!=typeof t)throw new Error(`padding.encode: non-string input=${t}`);for(;r.length*t%8;)r.push(e);return r},decode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let t of r)if("string"!=typeof t)throw new Error(`padding.decode: non-string input=${t}`);let n=r.length;if(n*t%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;n>0&&r[n-1]===e;n--)if(!((n-1)*t%8))throw new Error("Invalid padding: string has too much padding");return r.slice(0,n)}}}function g(t){if("function"!=typeof t)throw new Error("normalize fn should be function");return{encode:t=>t,decode:e=>t(e)}}function p(t,e,r){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);if(!Array.isArray(t))throw new Error("convertRadix: data should be array");if(!t.length)return[];let n=0;const o=[],i=Array.from(t);for(i.forEach((t=>{if(c(t),t<0||t>=e)throw new Error(`Wrong integer: ${t}`)}));;){let t=0,s=!0;for(let o=n;o<i.length;o++){const f=i[o],a=e*t+f;if(!Number.isSafeInteger(a)||e*t/e!==t||a-f!=e*t)throw new Error("convertRadix: carry overflow");if(t=a%r,i[o]=Math.floor(a/r),!Number.isSafeInteger(i[o])||i[o]*r+t!==a)throw new Error("convertRadix: carry overflow");s&&(i[o]?s=!1:n=o)}if(o.push(t),s)break}for(let e=0;e<t.length-1&&0===t[e];e++)o.push(0);return o.reverse()}const y=(t,e)=>e?y(e,t%e):t,b=(t,e)=>t+(e-y(t,e));function E(t,e,r,n){if(!Array.isArray(t))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(b(e,r)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${b(e,r)}`);let o=0,i=0;const s=2**r-1,f=[];for(const n of t){if(c(n),n>=2**e)throw new Error(`convertRadix2: invalid data word=${n} from=${e}`);if(o=o<<e|n,i+e>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);for(i+=e;i>=r;i-=r)f.push((o>>i-r&s)>>>0);o&=2**i-1}if(o=o<<r-i&s,!n&&i>=e)throw new Error("Excess padding");if(!n&&o)throw new Error(`Non-zero padding: ${o}`);return n&&i>0&&f.push(o>>>0),f}function m(t,e=!1){if(c(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(b(8,t)>32||b(t,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!(r instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return E(Array.from(r),8,t,!e)},decode:r=>{if(!Array.isArray(r)||r.length&&"number"!=typeof r[0])throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(E(r,t,8,e))}}}function v(t){if("function"!=typeof t)throw new Error("unsafeWrapper fn should be function");return function(...e){try{return t.apply(null,e)}catch(t){}}}h(m(4),d("0123456789ABCDEF"),l("")),h(m(5),d("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),w(5),l("")),h(m(5),d("0123456789ABCDEFGHIJKLMNOPQRSTUV"),w(5),l("")),h(m(5),d("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),l(""),g((t=>t.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")))),h(m(6),d("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),w(6),l("")),h(m(6),d("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),w(6),l(""));const x=t=>{return h((c(e=58),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return p(Array.from(t),256,e)},decode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("radix.decode input should be array of strings");return Uint8Array.from(p(t,e,256))}}),d(t),l(""));var e},B=(x("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),x("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),x("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz"),h(d("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),l(""))),A=[996825010,642813549,513874426,1027748829,705979059];function I(t){const e=t>>25;let r=(33554431&t)<<5;for(let t=0;t<A.length;t++)1==(e>>t&1)&&(r^=A[t]);return r}function S(t,e,r=1){const n=t.length;let o=1;for(let e=0;e<n;e++){const r=t.charCodeAt(e);if(r<33||r>126)throw new Error(`Invalid prefix (${t})`);o=I(o)^r>>5}o=I(o);for(let e=0;e<n;e++)o=I(o)^31&t.charCodeAt(e);for(let t of e)o=I(o)^t;for(let t=0;t<6;t++)o=I(o);return o^=r,B.encode(E([o%2**30],30,5,!1))}function L(t){const e="bech32"===t?1:734539939,r=m(5),n=r.decode,o=r.encode,i=v(n);function s(t,r=90){if("string"!=typeof t)throw new Error("bech32.decode input should be string, not "+typeof t);if(t.length<8||!1!==r&&t.length>r)throw new TypeError(`Wrong string length: ${t.length} (${t}). Expected (8..${r})`);const n=t.toLowerCase();if(t!==n&&t!==t.toUpperCase())throw new Error("String must be lowercase or uppercase");const o=(t=n).lastIndexOf("1");if(0===o||-1===o)throw new Error('Letter "1" must be present between prefix and data only');const i=t.slice(0,o),s=t.slice(o+1);if(s.length<6)throw new Error("Data must be at least 6 characters long");const f=B.decode(s).slice(0,-6),a=S(i,f,e);if(!s.endsWith(a))throw new Error(`Invalid checksum in ${t}: expected "${a}"`);return{prefix:i,words:f}}return{encode:function(t,r,n=90){if("string"!=typeof t)throw new Error("bech32.encode prefix should be string, not "+typeof t);if(!Array.isArray(r)||r.length&&"number"!=typeof r[0])throw new Error("bech32.encode words should be array of numbers, not "+typeof r);const o=t.length+7+r.length;if(!1!==n&&o>n)throw new TypeError(`Length ${o} exceeds limit ${n}`);return`${t=t.toLowerCase()}1${B.encode(r)}${S(t,r,e)}`},decode:s,decodeToBytes:function(t){const{prefix:e,words:r}=s(t,!1);return{prefix:e,words:r,bytes:n(r)}},decodeUnsafe:v(s),fromWords:n,fromWordsUnsafe:i,toWords:o}}const U=L("bech32");L("bech32m");h(m(4),d("0123456789abcdef"),l(""),g((t=>{if("string"!=typeof t||t.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);return t.toLowerCase()})));var O=new TextDecoder("utf-8"),$=(new TextEncoder,5e3);function R(t){let e={},r=t;for(;r.length>0;){let t=r[0],n=r[1],o=r.slice(2,2+n);if(r=r.slice(2+n),o.length<n)throw new Error(`not enough data to read on TLV ${t}`);e[t]=e[t]||[],e[t].push(o)}return e}function N(t){return e="npub",r=function(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(e/2);for(let e=0;e<r.length;e++){const n=2*e,o=t.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");r[e]=i}return r}(t),function(t,e){let r=U.toWords(e);return U.encode(t,r,$)}(e,r);var e,r}function T(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function k(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function H(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const q="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,P=t=>t instanceof Uint8Array,C=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),F=(t,e)=>t<<32-e|t>>>e;if(68!==new Uint8Array(new Uint32Array([287454020]).buffer)[0])throw new Error("Non little-endian hardware is not supported");function V(t){if("string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),!P(t))throw new Error("expected Uint8Array, got "+typeof t);return t}class z{clone(){return this._cloneInto()}}function D(t){const e=e=>t().update(V(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function j(t=32){if(q&&"function"==typeof q.getRandomValues)return q.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class K extends z{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=C(this.buffer)}update(t){H(this);const{view:e,buffer:r,blockLen:n}=this,o=(t=V(t)).length;for(let i=0;i<o;){const s=Math.min(n-this.pos,o-i);if(s!==n)r.set(t.subarray(i,i+s),this.pos),this.pos+=s,i+=s,this.pos===n&&(this.process(e,0),this.pos=0);else{const e=C(t);for(;n<=o-i;i+=n)this.process(e,i)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){H(this),function(t,e){k(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:o}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>n-i&&(this.process(r,0),i=0);for(let t=i;t<n;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),f=Number(r&i),a=n?4:0,u=n?0:4;t.setUint32(e+a,s,n),t.setUint32(e+u,f,n)}(r,n-8,BigInt(8*this.length),o),this.process(r,0);const s=C(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<a;t++)s.setUint32(4*t,u[t],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return t.length=n,t.pos=s,t.finished=o,t.destroyed=i,n%e&&t.buffer.set(r),t}}const Z=(t,e,r)=>t&e^t&r^e&r,W=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),_=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),G=new Uint32Array(64);class M extends K{constructor(){super(64,32,8,!1),this.A=0|_[0],this.B=0|_[1],this.C=0|_[2],this.D=0|_[3],this.E=0|_[4],this.F=0|_[5],this.G=0|_[6],this.H=0|_[7]}get(){const{A:t,B:e,C:r,D:n,E:o,F:i,G:s,H:f}=this;return[t,e,r,n,o,i,s,f]}set(t,e,r,n,o,i,s,f){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|f}process(t,e){for(let r=0;r<16;r++,e+=4)G[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=G[t-15],r=G[t-2],n=F(e,7)^F(e,18)^e>>>3,o=F(r,17)^F(r,19)^r>>>10;G[t]=o+G[t-7]+n+G[t-16]|0}let{A:r,B:n,C:o,D:i,E:s,F:f,G:a,H:u}=this;for(let t=0;t<64;t++){const e=u+(F(s,6)^F(s,11)^F(s,25))+((c=s)&f^~c&a)+W[t]+G[t]|0,h=(F(r,2)^F(r,13)^F(r,22))+Z(r,n,o)|0;u=a,a=f,f=s,s=i+e|0,i=o,o=n,n=r,r=e+h|0}var c;r=r+this.A|0,n=n+this.B|0,o=o+this.C|0,i=i+this.D|0,s=s+this.E|0,f=f+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(r,n,o,i,s,f,a,u)}roundClean(){G.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Y=D((()=>new M)),J=(BigInt(0),BigInt(1)),Q=BigInt(2),X=t=>t instanceof Uint8Array,tt=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function et(t){if(!X(t))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=tt[t[r]];return e}function rt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":`0x${t}`)}function nt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(e/2);for(let e=0;e<r.length;e++){const n=2*e,o=t.slice(n,n+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");r[e]=i}return r}function ot(t){return rt(et(t))}function it(t){if(!X(t))throw new Error("Uint8Array expected");return rt(et(Uint8Array.from(t).reverse()))}function st(t,e){return nt(t.toString(16).padStart(2*e,"0"))}function ft(t,e){return st(t,e).reverse()}function at(t,e,r){let n;if("string"==typeof e)try{n=nt(e)}catch(r){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)}else{if(!X(e))throw new Error(`${t} must be hex string or Uint8Array`);n=Uint8Array.from(e)}const o=n.length;if("number"==typeof r&&o!==r)throw new Error(`${t} expected ${r} bytes, got ${o}`);return n}function ut(...t){const e=new Uint8Array(t.reduce(((t,e)=>t+e.length),0));let r=0;return t.forEach((t=>{if(!X(t))throw new Error("Uint8Array expected");e.set(t,r),r+=t.length})),e}const ct=t=>(Q<<BigInt(t-1))-J,ht=t=>new Uint8Array(t),dt=t=>Uint8Array.from(t);function lt(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=ht(t),o=ht(t),i=0;const s=()=>{n.fill(1),o.fill(0),i=0},f=(...t)=>r(o,n,...t),a=(t=ht())=>{o=f(dt([0]),t),n=f(),0!==t.length&&(o=f(dt([1]),t),n=f())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=f();const e=n.slice();r.push(e),t+=n.length}return ut(...r)};return(t,e)=>{let r;for(s(),a(t);!(r=e(u()));)a();return s(),r}}const wt={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function gt(t,e,r={}){const n=(e,r,n)=>{const o=wt[r];if("function"!=typeof o)throw new Error(`Invalid validator "${r}", expected function`);const i=t[e];if(!(n&&void 0===i||o(i,t)))throw new Error(`Invalid param ${String(e)}=${i} (${typeof i}), expected ${r}`)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}const pt=BigInt(0),yt=BigInt(1),bt=BigInt(2),Et=BigInt(3),mt=BigInt(4),vt=BigInt(5),xt=BigInt(8);function Bt(t,e){const r=t%e;return r>=pt?r:e+r}function At(t,e,r){if(r<=pt||e<pt)throw new Error("Expected power/modulo > 0");if(r===yt)return pt;let n=yt;for(;e>pt;)e&yt&&(n=n*t%r),t=t*t%r,e>>=yt;return n}function It(t,e,r){let n=t;for(;e-- >pt;)n*=n,n%=r;return n}function St(t,e){if(t===pt||e<=pt)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=Bt(t,e),n=e,o=pt,i=yt,s=yt,f=pt;for(;r!==pt;){const t=n/r,e=n%r,a=o-s*t,u=i-f*t;n=r,r=e,o=s,i=f,s=a,f=u}if(n!==yt)throw new Error("invert: does not exist");return Bt(o,e)}BigInt(9),BigInt(16);const Lt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ut(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Ot(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function $t(t){const e=Ot(t);return e+Math.ceil(e/2)}class Rt extends z{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");T(t.outputLen),T(t.blockLen)}(t);const r=V(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,o=new Uint8Array(n);o.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<o.length;t++)o[t]^=54;this.iHash.update(o),this.oHash=t.create();for(let t=0;t<o.length;t++)o[t]^=106;this.oHash.update(o),o.fill(0)}update(t){return H(this),this.iHash.update(t),this}digestInto(t){H(this),k(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=n,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Nt=(t,e,r)=>new Rt(t,e).update(r).digest();Nt.create=(t,e)=>new Rt(t,e);const Tt=BigInt(0),kt=BigInt(1);function Ht(t){return gt(t.Fp,Lt.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),gt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ut(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}const{Ph:qt,aT:Pt}=e,Ct={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(t){const{Err:e}=Ct;if(t.length<2||2!==t[0])throw new e("Invalid signature integer tag");const r=t[1],n=t.subarray(2,r+2);if(!r||n.length!==r)throw new e("Invalid signature integer: wrong length");if(128&n[0])throw new e("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new e("Invalid signature integer: unnecessary leading zero");return{d:qt(n),l:t.subarray(r+2)}},toSig(t){const{Err:e}=Ct,r="string"==typeof t?Pt(t):t;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new e("Invalid signature tag");if(r[1]!==n-2)throw new e("Invalid signature: incorrect length");const{d:o,l:i}=Ct._parseInt(r.subarray(2)),{d:s,l:f}=Ct._parseInt(i);if(f.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s}},hexFromSig(t){const e=t=>8&Number.parseInt(t[0],16)?"00"+t:t,r=t=>{const e=t.toString(16);return 1&e.length?`0${e}`:e},n=e(r(t.s)),o=e(r(t.r)),i=n.length/2,s=o.length/2,f=r(i),a=r(s);return`30${r(s+i+4)}02${a}${o}02${f}${n}`}},Ft=BigInt(0),Vt=BigInt(1),zt=(BigInt(2),BigInt(3));function Dt(t){const e=function(t){const e=Ht(t);return gt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n}=e,o=r.BYTES+1,i=2*r.BYTES+1;function s(t){return Bt(t,n)}function f(t){return St(t,n)}const{ProjectivePoint:a,normPrivateKeyToScalar:u,weierstrassEquation:c,isWithinCurveOrder:h}=function(t){const e=function(t){const e=Ht(t);gt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:o}=e;if(r){if(!n.eql(o,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=e.toBytes||((t,e,n)=>{const o=e.toAffine();return ut(Uint8Array.from([4]),r.toBytes(o.x),r.toBytes(o.y))}),o=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function i(t){const{a:n,b:o}=e,i=r.sqr(t),s=r.mul(i,t);return r.add(r.add(s,r.mul(t,n)),o)}if(!r.eql(r.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function s(t){return"bigint"==typeof t&&Ft<t&&t<e.n}function f(t){if(!s(t))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:o,n:i}=e;if(r&&"bigint"!=typeof t){if(t instanceof Uint8Array&&(t=et(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("Invalid key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:ot(at("private key",t,n))}catch(e){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)}return o&&(s=Bt(s,i)),f(s),s}const u=new Map;function c(t){if(!(t instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof h)throw new Error("projective point not allowed");const o=t=>r.eql(t,r.ZERO);return o(e)&&o(n)?h.ZERO:new h(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(h.fromAffine)}static fromHex(t){const e=h.fromAffine(o(at("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return h.BASE.multiply(a(t))}_setWindowSize(t){this._WINDOW_SIZE=t,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:t,y:n}=this.toAffine();if(!r.isValid(t)||!r.isValid(n))throw new Error("bad point: x or y not FE");const o=r.sqr(n),s=i(t);if(!r.eql(o,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){c(t);const{px:e,py:n,pz:o}=this,{px:i,py:s,pz:f}=t,a=r.eql(r.mul(e,f),r.mul(i,o)),u=r.eql(r.mul(n,f),r.mul(s,o));return a&&u}negate(){return new h(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,o=r.mul(n,zt),{px:i,py:s,pz:f}=this;let a=r.ZERO,u=r.ZERO,c=r.ZERO,d=r.mul(i,i),l=r.mul(s,s),w=r.mul(f,f),g=r.mul(i,s);return g=r.add(g,g),c=r.mul(i,f),c=r.add(c,c),a=r.mul(t,c),u=r.mul(o,w),u=r.add(a,u),a=r.sub(l,u),u=r.add(l,u),u=r.mul(a,u),a=r.mul(g,a),c=r.mul(o,c),w=r.mul(t,w),g=r.sub(d,w),g=r.mul(t,g),g=r.add(g,c),c=r.add(d,d),d=r.add(c,d),d=r.add(d,w),d=r.mul(d,g),u=r.add(u,d),w=r.mul(s,f),w=r.add(w,w),d=r.mul(w,g),a=r.sub(a,d),c=r.mul(w,l),c=r.add(c,c),c=r.add(c,c),new h(a,u,c)}add(t){c(t);const{px:n,py:o,pz:i}=this,{px:s,py:f,pz:a}=t;let u=r.ZERO,d=r.ZERO,l=r.ZERO;const w=e.a,g=r.mul(e.b,zt);let p=r.mul(n,s),y=r.mul(o,f),b=r.mul(i,a),E=r.add(n,o),m=r.add(s,f);E=r.mul(E,m),m=r.add(p,y),E=r.sub(E,m),m=r.add(n,i);let v=r.add(s,a);return m=r.mul(m,v),v=r.add(p,b),m=r.sub(m,v),v=r.add(o,i),u=r.add(f,a),v=r.mul(v,u),u=r.add(y,b),v=r.sub(v,u),l=r.mul(w,m),u=r.mul(g,b),l=r.add(u,l),u=r.sub(y,l),l=r.add(y,l),d=r.mul(u,l),y=r.add(p,p),y=r.add(y,p),b=r.mul(w,b),m=r.mul(g,m),y=r.add(y,b),b=r.sub(p,b),b=r.mul(w,b),m=r.add(m,b),p=r.mul(y,m),d=r.add(d,p),p=r.mul(v,m),u=r.mul(E,u),u=r.sub(u,p),p=r.mul(E,y),l=r.mul(v,l),l=r.add(l,p),new h(u,d,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(h.ZERO)}wNAF(t){return l.wNAFCached(this,u,t,(t=>{const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(h.fromAffine)}))}multiplyUnsafe(t){const n=h.ZERO;if(t===Ft)return n;if(f(t),t===Vt)return this;const{endo:o}=e;if(!o)return l.unsafeLadder(this,t);let{k1neg:i,k1:s,k2neg:a,k2:u}=o.splitScalar(t),c=n,d=n,w=this;for(;s>Ft||u>Ft;)s&Vt&&(c=c.add(w)),u&Vt&&(d=d.add(w)),w=w.double(),s>>=Vt,u>>=Vt;return i&&(c=c.negate()),a&&(d=d.negate()),d=new h(r.mul(d.px,o.beta),d.py,d.pz),c.add(d)}multiply(t){f(t);let n,o,i=t;const{endo:s}=e;if(s){const{k1neg:t,k1:e,k2neg:f,k2:a}=s.splitScalar(i);let{p:u,f:c}=this.wNAF(e),{p:d,f:w}=this.wNAF(a);u=l.constTimeNegate(t,u),d=l.constTimeNegate(f,d),d=new h(r.mul(d.px,s.beta),d.py,d.pz),n=u.add(d),o=c.add(w)}else{const{p:t,f:e}=this.wNAF(i);n=t,o=e}return h.normalizeZ([n,o])[0]}multiplyAndAddUnsafe(t,e,r){const n=h.BASE,o=(t,e)=>e!==Ft&&e!==Vt&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,r));return i.is0()?void 0:i}toAffine(t){const{px:e,py:n,pz:o}=this,i=this.is0();null==t&&(t=i?r.ONE:r.inv(o));const s=r.mul(e,t),f=r.mul(n,t),a=r.mul(o,t);if(i)return{x:r.ZERO,y:r.ZERO};if(!r.eql(a,r.ONE))throw new Error("invZ was invalid");return{x:s,y:f}}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Vt)return!0;if(r)return r(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Vt?this:r?r(h,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return this.assertValidity(),n(h,this,t)}toHex(t=!0){return et(this.toRawBytes(t))}}h.BASE=new h(e.Gx,e.Gy,r.ONE),h.ZERO=new h(r.ZERO,r.ONE,r.ZERO);const d=e.nBitLength,l=function(t,e){const r=(t,e)=>{const r=e.negate();return t?r:e},n=t=>({windows:Math.ceil(e/t)+1,windowSize:2**(t-1)});return{constTimeNegate:r,unsafeLadder(e,r){let n=t.ZERO,o=e;for(;r>Tt;)r&kt&&(n=n.add(o)),o=o.double(),r>>=kt;return n},precomputeWindow(t,e){const{windows:r,windowSize:o}=n(e),i=[];let s=t,f=s;for(let t=0;t<r;t++){f=s,i.push(f);for(let t=1;t<o;t++)f=f.add(s),i.push(f);s=f.double()}return i},wNAF(e,o,i){const{windows:s,windowSize:f}=n(e);let a=t.ZERO,u=t.BASE;const c=BigInt(2**e-1),h=2**e,d=BigInt(e);for(let t=0;t<s;t++){const e=t*f;let n=Number(i&c);i>>=d,n>f&&(n-=h,i+=kt);const s=e,l=e+Math.abs(n)-1,w=t%2!=0,g=n<0;0===n?u=u.add(r(w,o[s])):a=a.add(r(g,o[l]))}return{p:a,f:u}},wNAFCached(t,e,r,n){const o=t._WINDOW_SIZE||1;let i=e.get(t);return i||(i=this.precomputeWindow(t,o),1!==o&&e.set(t,n(i))),this.wNAF(o,i,r)}}}(h,e.endo?Math.ceil(d/2):d);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:a,weierstrassEquation:i,isWithinCurveOrder:s}}({...e,toBytes(t,e,n){const o=e.toAffine(),i=r.toBytes(o.x),s=ut;return n?s(Uint8Array.from([e.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,r.toBytes(o.y))},fromBytes(t){const e=t.length,n=t[0],s=t.subarray(1);if(e!==o||2!==n&&3!==n){if(e===i&&4===n)return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))};throw new Error(`Point of length ${e} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}{const t=ot(s);if(!(Ft<(f=t)&&f<r.ORDER))throw new Error("Point is not on curve");const e=c(t);let o=r.sqrt(e);return!(1&~n)!=((o&Vt)===Vt)&&(o=r.neg(o)),{x:t,y:o}}var f}}),d=t=>et(st(t,e.nByteLength));function l(t){return t>n>>Vt}const w=(t,e,r)=>ot(t.slice(e,r));class g{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=at("compactSignature",t,2*r),new g(w(t,0,r),w(t,r,2*r))}static fromDER(t){const{r:e,s:r}=Ct.toSig(at("DER",t));return new g(e,r)}assertValidity(){if(!h(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!h(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(t){return new g(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:o,recovery:i}=this,u=E(at("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const c=2===i||3===i?n+e.n:n;if(c>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=1&i?"03":"02",l=a.fromHex(h+d(c)),w=f(c),g=s(-u*w),p=s(o*w),y=a.BASE.multiplyAndAddUnsafe(l,g,p);if(!y)throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return l(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return nt(this.toDERHex())}toDERHex(){return Ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return nt(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const p={isValidPrivateKey(t){try{return u(t),!0}catch(t){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const t=$t(e.n);return function(t,e,r=!1){const n=t.length,o=Ot(e),i=$t(e);if(n<16||n<i||n>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${n}`);const s=Bt(r?ot(t):it(t),e-yt)+yt;return r?ft(s,o):st(s,o)}(e.randomBytes(t),e.n)},precompute:(t=8,e=a.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function y(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?n===o||n===i:r?n===2*o||n===2*i:t instanceof a}const b=e.bits2int||function(t){const r=ot(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r},E=e.bits2int_modN||function(t){return s(b(t))},m=ct(e.nBitLength);function v(t){if("bigint"!=typeof t)throw new Error("bigint expected");if(!(Ft<=t&&t<m))throw new Error(`bigint expected < 2^${e.nBitLength}`);return st(t,e.nByteLength)}const x={lowS:e.lowS,prehash:!1},B={lowS:e.lowS,prehash:!1};return a.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return a.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(y(t))throw new Error("first arg must be private key");if(!y(e))throw new Error("second arg must be public key");return a.fromHex(e).multiply(u(t)).toRawBytes(r)},sign:function(t,n,o=x){const{seed:i,k2sig:c}=function(t,n,o=x){if(["recovered","canonical"].some((t=>t in o)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:c}=e;let{lowS:d,prehash:w,extraEntropy:p}=o;null==d&&(d=!0),t=at("msgHash",t),w&&(t=at("prehashed msgHash",i(t)));const y=E(t),m=u(n),B=[v(m),v(y)];if(null!=p){const t=!0===p?c(r.BYTES):p;B.push(at("extraEntropy",t))}const A=ut(...B),I=y;return{seed:A,k2sig:function(t){const e=b(t);if(!h(e))return;const r=f(e),n=a.BASE.multiply(e).toAffine(),o=s(n.x);if(o===Ft)return;const i=s(r*s(I+o*m));if(i===Ft)return;let u=(n.x===o?0:2)|Number(n.y&Vt),c=i;return d&&l(i)&&(c=function(t){return l(t)?s(-t):t}(i),u^=1),new g(o,c,u)}}}(t,n,o),d=e;return lt(d.hash.outputLen,d.nByteLength,d.hmac)(i,c)},verify:function(t,r,n,o=B){const i=t;if(r=at("msgHash",r),n=at("publicKey",n),"strict"in o)throw new Error("options.strict was renamed to lowS");const{lowS:u,prehash:c}=o;let h,d;try{if("string"==typeof i||i instanceof Uint8Array)try{h=g.fromDER(i)}catch(t){if(!(t instanceof Ct.Err))throw t;h=g.fromCompact(i)}else{if("object"!=typeof i||"bigint"!=typeof i.r||"bigint"!=typeof i.s)throw new Error("PARSE");{const{r:t,s:e}=i;h=new g(t,e)}}d=a.fromHex(n)}catch(t){if("PARSE"===t.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(u&&h.hasHighS())return!1;c&&(r=e.hash(r));const{r:l,s:w}=h,p=E(r),y=f(w),b=s(p*y),m=s(l*y),v=a.BASE.multiplyAndAddUnsafe(d,b,m)?.toAffine();return!!v&&s(v.x)===l},ProjectivePoint:a,Signature:g,utils:p}}function jt(t){return{hash:t,hmac:(e,...r)=>Nt(t,e,function(...t){const e=new Uint8Array(t.reduce(((t,e)=>t+e.length),0));let r=0;return t.forEach((t=>{if(!P(t))throw new Error("Uint8Array expected");e.set(t,r),r+=t.length})),e}(...r)),randomBytes:j}}BigInt(4);const Kt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Zt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Wt=BigInt(1),_t=BigInt(2),Gt=(t,e)=>(t+e/_t)/e;function Mt(t){const e=Kt,r=BigInt(3),n=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),f=BigInt(44),a=BigInt(88),u=t*t*t%e,c=u*u*t%e,h=It(c,r,e)*c%e,d=It(h,r,e)*c%e,l=It(d,_t,e)*u%e,w=It(l,o,e)*l%e,g=It(w,i,e)*w%e,p=It(g,f,e)*g%e,y=It(p,a,e)*p%e,b=It(y,f,e)*g%e,E=It(b,r,e)*c%e,m=It(E,s,e)*w%e,v=It(m,n,e)*u%e,x=It(v,_t,e);if(!Yt.eql(Yt.sqr(x),t))throw new Error("Cannot find square root");return x}const Yt=function(t,e,r=!1,n={}){if(t<=pt)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:i}=Ut(t,e);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=function(t){if(t%mt===Et){const e=(t+yt)/mt;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}if(t%xt===vt){const e=(t-vt)/xt;return function(t,r){const n=t.mul(r,bt),o=t.pow(n,e),i=t.mul(r,o),s=t.mul(t.mul(i,bt),o),f=t.mul(i,t.sub(s,t.ONE));if(!t.eql(t.sqr(f),r))throw new Error("Cannot find square root");return f}}return function(t){const e=(t-yt)/bt;let r,n,o;for(r=t-yt,n=0;r%bt===pt;r/=bt,n++);for(o=bt;o<t&&At(o,e,t)!==t-yt;o++);if(1===n){const e=(t+yt)/mt;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw new Error("Cannot find square root");return n}}const i=(r+yt)/bt;return function(t,s){if(t.pow(s,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let f=n,a=t.pow(t.mul(t.ONE,o),r),u=t.pow(s,i),c=t.pow(s,r);for(;!t.eql(c,t.ONE);){if(t.eql(c,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(c);e<f&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(a,yt<<BigInt(f-e-1));a=t.sqr(r),u=t.mul(u,r),c=t.mul(c,a),f=e}return u}}(t)}(t),f=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:ct(o),ZERO:pt,ONE:yt,create:e=>Bt(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("Invalid field element: expected bigint, got "+typeof e);return pt<=e&&e<t},is0:t=>t===pt,isOdd:t=>(t&yt)===yt,neg:e=>Bt(-e,t),eql:(t,e)=>t===e,sqr:e=>Bt(e*e,t),add:(e,r)=>Bt(e+r,t),sub:(e,r)=>Bt(e-r,t),mul:(e,r)=>Bt(e*r,t),pow:(t,e)=>function(t,e,r){if(r<pt)throw new Error("Expected power > 0");if(r===pt)return t.ONE;if(r===yt)return e;let n=t.ONE,o=e;for(;r>pt;)r&yt&&(n=t.mul(n,o)),o=t.sqr(o),r>>=yt;return n}(f,t,e),div:(e,r)=>Bt(e*St(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>St(e,t),sqrt:n.sqrt||(t=>s(f,t)),invertBatch:t=>function(t,e){const r=new Array(e.length),n=e.reduce(((e,n,o)=>t.is0(n)?e:(r[o]=e,t.mul(e,n))),t.ONE),o=t.inv(n);return e.reduceRight(((e,n,o)=>t.is0(n)?e:(r[o]=t.mul(e,r[o]),t.mul(e,n))),o),r}(f,t),cmov:(t,e,r)=>r?e:t,toBytes:t=>r?ft(t,i):st(t,i),fromBytes:t=>{if(t.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${t.length}`);return r?it(t):ot(t)}});return Object.freeze(f)}(Kt,void 0,void 0,{sqrt:Mt}),Jt=function(t,e){const r=e=>Dt({...t,...jt(e)});return Object.freeze({...r(e),create:r})}({a:BigInt(0),b:BigInt(7),Fp:Yt,n:Zt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Zt,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Wt*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,s=BigInt("0x100000000000000000000000000000000"),f=Gt(i*t,e),a=Gt(-n*t,e);let u=Bt(t-f*r-a*o,e),c=Bt(-f*n-a*i,e);const h=u>s,d=c>s;if(h&&(u=e-u),d&&(c=e-c),u>s||c>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:h,k1:u,k2neg:d,k2:c}}}},Y),Qt=BigInt(0),Xt=t=>"bigint"==typeof t&&Qt<t&&t<Kt,te=t=>"bigint"==typeof t&&Qt<t&&t<Zt,ee={};function re(t,...e){let r=ee[t];if(void 0===r){const e=Y(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=ut(e,e),ee[t]=r}return Y(ut(r,...e))}const ne=t=>t.toRawBytes(!0).slice(1),oe=t=>st(t,32),ie=t=>Bt(t,Kt),se=t=>Bt(t,Zt),fe=Jt.ProjectivePoint,ae=(t,e,r)=>fe.BASE.multiplyAndAddUnsafe(t,e,r);function ue(t){let e=Jt.utils.normPrivateKeyToScalar(t),r=fe.fromPrivateKey(e);return{scalar:r.hasEvenY()?e:se(-e),bytes:ne(r)}}function ce(t){if(!Xt(t))throw new Error("bad x: need 0 < x < p");const e=ie(t*t);let r=Mt(ie(e*t+BigInt(7)));r%_t!==Qt&&(r=ie(-r));const n=new fe(t,r,Wt);return n.assertValidity(),n}function he(...t){return se(ot(re("BIP0340/challenge",...t)))}function de(t){return ue(t).bytes}function le(t,e,r=j(32)){const n=at("message",t),{bytes:o,scalar:i}=ue(e),s=at("auxRand",r,32),f=oe(i^ot(re("BIP0340/aux",s))),a=re("BIP0340/nonce",f,o,n),u=se(ot(a));if(u===Qt)throw new Error("sign failed: k is zero");const{bytes:c,scalar:h}=ue(u),d=he(c,o,n),l=new Uint8Array(64);if(l.set(c,0),l.set(oe(se(h+d*i)),32),!we(l,n,o))throw new Error("sign: Invalid signature produced");return l}function we(t,e,r){const n=at("signature",t,64),o=at("message",e),i=at("publicKey",r,32);try{const t=ce(ot(i)),e=ot(n.subarray(0,32));if(!Xt(e))return!1;const r=ot(n.subarray(32,64));if(!te(r))return!1;const s=he(oe(e),ne(t),o),f=ae(t,r,se(-s));return!(!f||!f.hasEvenY()||f.toAffine().x!==e)}catch(t){return!1}}const ge=(()=>({getPublicKey:de,sign:le,verify:we,utils:{randomPrivateKey:Jt.utils.randomPrivateKey,lift_x:ce,pointToBytes:ne,numberToBytesBE:st,bytesToNumberBE:ot,taggedHash:re,mod:Bt}}))();function pe(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function ye(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}const be={number:pe,bool:function(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)},bytes:ye,hash:function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");pe(t.outputLen),pe(t.blockLen)},exists:function(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")},output:function(t,e){ye(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}};class Ee extends a{constructor(t,e,r,o){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=n(this.buffer)}update(t){be.exists(this);const{view:e,buffer:r,blockLen:o}=this,i=(t=f(t)).length;for(let s=0;s<i;){const f=Math.min(o-this.pos,i-s);if(f!==o)r.set(t.subarray(s,s+f),this.pos),this.pos+=f,s+=f,this.pos===o&&(this.process(e,0),this.pos=0);else{const e=n(t);for(;o<=i-s;s+=o)this.process(e,s)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){be.exists(this),be.output(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:i}=this;let{pos:s}=this;e[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let t=s;t<o;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),f=Number(r&i),a=n?4:0,u=n?0:4;t.setUint32(e+a,s,n),t.setUint32(e+u,f,n)}(r,o-8,BigInt(8*this.length),i),this.process(r,0);const f=n(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=a/4,c=this.get();if(u>c.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<u;t++)f.setUint32(4*t,c[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return t.length=n,t.pos=s,t.finished=o,t.destroyed=i,n%e&&t.buffer.set(r),t}}const me=(t,e,r)=>t&e^t&r^e&r,ve=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),xe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Be=new Uint32Array(64);class Ae extends Ee{constructor(){super(64,32,8,!1),this.A=0|xe[0],this.B=0|xe[1],this.C=0|xe[2],this.D=0|xe[3],this.E=0|xe[4],this.F=0|xe[5],this.G=0|xe[6],this.H=0|xe[7]}get(){const{A:t,B:e,C:r,D:n,E:o,F:i,G:s,H:f}=this;return[t,e,r,n,o,i,s,f]}set(t,e,r,n,o,i,s,f){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|f}process(t,e){for(let r=0;r<16;r++,e+=4)Be[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=Be[t-15],r=Be[t-2],n=o(e,7)^o(e,18)^e>>>3,i=o(r,17)^o(r,19)^r>>>10;Be[t]=i+Be[t-7]+n+Be[t-16]|0}let{A:r,B:n,C:i,D:s,E:f,F:a,G:u,H:c}=this;for(let t=0;t<64;t++){const e=c+(o(f,6)^o(f,11)^o(f,25))+((h=f)&a^~h&u)+ve[t]+Be[t]|0,d=(o(r,2)^o(r,13)^o(r,22))+me(r,n,i)|0;c=u,u=a,a=f,f=s+e|0,s=i,i=n,n=r,r=e+d|0}var h;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,s=s+this.D|0,f=f+this.E|0,a=a+this.F|0,u=u+this.G|0,c=c+this.H|0,this.set(r,n,i,s,f,a,u,c)}roundClean(){Be.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class Ie extends Ae{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Se=u((()=>new Ae));u((()=>new Ie));var Le=Symbol("verified"),Ue=t=>t instanceof Object;new TextDecoder("utf-8");var Oe=new TextEncoder;function $e(t){return s(Se(Oe.encode(function(t){if(!function(t){if(!Ue(t))return!1;if("number"!=typeof t.kind)return!1;if("string"!=typeof t.content)return!1;if("number"!=typeof t.created_at)return!1;if("string"!=typeof t.pubkey)return!1;if(!t.pubkey.match(/^[a-f0-9]{64}$/))return!1;if(!Array.isArray(t.tags))return!1;for(let e=0;e<t.tags.length;e++){let r=t.tags[e];if(!Array.isArray(r))return!1;for(let t=0;t<r.length;t++)if("object"==typeof r[t])return!1}return!0}(t))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content])}(t))))}var Re=new class{generateSecretKey(){return ge.utils.randomPrivateKey()}getPublicKey(t){return s(ge.getPublicKey(t))}finalizeEvent(t,e){const r=t;return r.pubkey=s(ge.getPublicKey(e)),r.id=$e(r),r.sig=s(ge.sign($e(r),e)),r[Le]=!0,r}verifyEvent(t){if("boolean"==typeof t[Le])return t[Le];const e=$e(t);if(e!==t.id)return t[Le]=!1,!1;try{const r=ge.verify(t.sig,e,t.pubkey);return t[Le]=r,r}catch(e){return t[Le]=!1,!1}}},Ne=(Re.generateSecretKey,Re.getPublicKey,Re.finalizeEvent,Re.verifyEvent);(async()=>{const t=document.getElementById("message"),e=new Set(["error","success","warning"]);function r(r,n){let o=new Set(e);o.delete(n),o=Array.from(o),t.classList.remove(...o),t.classList.add(n),t.textContent=r,t.classList.remove("hidden")}function n(t){r(t,"error")}function o(t){r(t,"success")}const i=document.getElementById("npub"),f=document.getElementById("event"),a=document.getElementById("sign-button"),u=document.getElementById("verify-button");a.addEventListener("click",(async function(){if(void 0!==window.nostr)try{let t=JSON.parse(f.value),e=await window.nostr.signEvent(t);f.value=JSON.stringify(e),console.log("npubEncode"),i.value=N(e.pubkey),o("Signed event"),console.log("Signing success")}catch(t){n("Failed to parse event"),console.log(`Failed to parse event, error: "${t}"`)}else n("NIP-07 Extension not detected")})),u.addEventListener("click",(function(){try{let t=JSON.parse(f.value),e=null;try{e=function(t){let{prefix:e,words:r}=U.decode(t,$),n=new Uint8Array(U.fromWords(r));switch(e){case"nprofile":{let t=R(n);if(!t[0]?.[0])throw new Error("missing TLV 0 for nprofile");if(32!==t[0][0].length)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:s(t[0][0]),relays:t[1]?t[1].map((t=>O.decode(t))):[]}}}case"nevent":{let t=R(n);if(!t[0]?.[0])throw new Error("missing TLV 0 for nevent");if(32!==t[0][0].length)throw new Error("TLV 0 should be 32 bytes");if(t[2]&&32!==t[2][0].length)throw new Error("TLV 2 should be 32 bytes");if(t[3]&&4!==t[3][0].length)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:s(t[0][0]),relays:t[1]?t[1].map((t=>O.decode(t))):[],author:t[2]?.[0]?s(t[2][0]):void 0,kind:t[3]?.[0]?parseInt(s(t[3][0]),16):void 0}}}case"naddr":{let t=R(n);if(!t[0]?.[0])throw new Error("missing TLV 0 for naddr");if(!t[2]?.[0])throw new Error("missing TLV 2 for naddr");if(32!==t[2][0].length)throw new Error("TLV 2 should be 32 bytes");if(!t[3]?.[0])throw new Error("missing TLV 3 for naddr");if(4!==t[3][0].length)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:O.decode(t[0][0]),pubkey:s(t[2][0]),kind:parseInt(s(t[3][0]),16),relays:t[1]?t[1].map((t=>O.decode(t))):[]}}}case"nrelay":{let t=R(n);if(!t[0]?.[0])throw new Error("missing TLV 0 for nrelay");return{type:"nrelay",data:O.decode(t[0][0])}}case"nsec":return{type:e,data:n};case"npub":case"note":return{type:e,data:s(n)};default:throw new Error(`unknown prefix ${e}`)}}(i.value)}catch(t){}if(null!==e&&e.data!=t.pubkey)return n("npub did not match event"),void console.log(`provided npub hex ${e}`);Ne(t)?null!=e?o("Event Validated!"):r("Event validated, but no npub checked","success"):(n("Event failed validation"),console.log("Event failed validation"))}catch(t){n("Failed to parse event"),console.log(`Failed to parse event, error: "${t}"`)}}))})()})();